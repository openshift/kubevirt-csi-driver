// Code generated for package generated by go-bindata DO NOT EDIT. (@generated)
// sources:
// deploy/000-csi-driver.yaml
// deploy/000-namespace.yaml
// deploy/020-autorization.yaml
// deploy/030-node.yaml
// deploy/040-controller.yaml
// deploy/configmap.yaml
// deploy/example/infracluster-kubeconfig.yaml
// deploy/example/kubevirt-config.yaml
// deploy/example/kubevirt.yaml
// deploy/example/storage-claim.yaml
// deploy/example/storageclass.yaml
// deploy/example/test-pod.yaml
// deploy/infra-cluster-service-account.yaml
// deploy/secret.yaml
package generated

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type asset struct {
	bytes []byte
	info  os.FileInfo
}

type bindataFileInfo struct {
	name    string
	size    int64
	mode    os.FileMode
	modTime time.Time
}

// Name return file name
func (fi bindataFileInfo) Name() string {
	return fi.name
}

// Size return file size
func (fi bindataFileInfo) Size() int64 {
	return fi.size
}

// Mode return file mode
func (fi bindataFileInfo) Mode() os.FileMode {
	return fi.mode
}

// Mode return file modify time
func (fi bindataFileInfo) ModTime() time.Time {
	return fi.modTime
}

// IsDir return file whether a directory
func (fi bindataFileInfo) IsDir() bool {
	return fi.mode&os.ModeDir != 0
}

// Sys return file is sys mode
func (fi bindataFileInfo) Sys() interface{} {
	return nil
}

var _deploy000CsiDriverYaml = []byte(`#TODO v1beta is deprecated in 1.19+ and promoted to v1
apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: csi.kubevirt.io
spec:
  attachRequired: true
  podInfoOnMount: true
`)

func deploy000CsiDriverYamlBytes() ([]byte, error) {
	return _deploy000CsiDriverYaml, nil
}

func deploy000CsiDriverYaml() (*asset, error) {
	bytes, err := deploy000CsiDriverYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/000-csi-driver.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deploy000NamespaceYaml = []byte(`apiVersion: v1
kind: Namespace
metadata:
  name: kubevirt-csi-driver
  annotations:
    openshift.io/node-selector: ""
  labels:
    name: kubevirt-csi-driver

`)

func deploy000NamespaceYamlBytes() ([]byte, error) {
	return _deploy000NamespaceYaml, nil
}

func deploy000NamespaceYaml() (*asset, error) {
	bytes, err := deploy000NamespaceYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/000-namespace.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deploy020AutorizationYaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  name: kubevirt-csi-node-sa
  namespace: kubevirt-csi-driver
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: kubevirt-csi-controller-sa
  namespace: kubevirt-csi-driver
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kubevirt-csi-controller-cr
rules:
  # Allow listing and creating CRDs
  - apiGroups: ['apiextensions.k8s.io']
    resources: ['customresourcedefinitions']
    verbs: ['list', 'create']
  - apiGroups: ['']
    resources: ['persistentvolumes']
    verbs: ['create', 'delete', 'get', 'list', 'watch', 'update', 'patch']
  - apiGroups: ['']
    resources: ['secrets']
    verbs: ['get', 'list']
  - apiGroups: ['']
    resources: ['persistentvolumeclaims']
    verbs: ['get', 'list', 'watch', 'update']
  - apiGroups: [""]
    resources: ["persistentvolumeclaims/status"]
    verbs: ["update", "patch"]
  - apiGroups: ['']
    resources: ['nodes']
    verbs: ['get', 'list', 'watch']
  - apiGroups: ['storage.k8s.io']
    resources: ['volumeattachments']
    verbs: ['get', 'list', 'watch', 'update', 'patch']
  - apiGroups: ['storage.k8s.io']
    resources: ['storageclasses']
    verbs: ['get', 'list', 'watch']
  - apiGroups: ['csi.storage.k8s.io']
    resources: ['csidrivers']
    verbs: ['get', 'list', 'watch', 'update', 'create']
  - apiGroups: ['']
    resources: ['events']
    verbs: ['list', 'watch', 'create', 'update', 'patch']
  - apiGroups: ["snapshot.storage.k8s.io"]
    resources: ["volumesnapshotclasses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["snapshot.storage.k8s.io"]
    resources: ["volumesnapshotcontents"]
    verbs: ["create", "get", "list", "watch", "update", "delete"]
  - apiGroups: ["snapshot.storage.k8s.io"]
    resources: ["volumesnapshots"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["snapshot.storage.k8s.io"]
    resources: ["volumesnapshots/status"]
    verbs: ["update"]
  - apiGroups: [ "storage.k8s.io" ]
    resources: [ "volumeattachments/status" ]
    verbs: [ "get", "list", "watch", "update", "patch" ]
  - apiGroups: ["storage.k8s.io"]
    resources: ["csinodes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["security.openshift.io"]
    resources: ["securitycontextconstraints"]
    verbs: ["use"]
    resourceNames: ["privileged"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kubevirt-csi-node-cr
rules:
  - apiGroups: [""]
    resources: ["persistentvolumes"]
    verbs: ["get", "list", "watch", "update", "create", "delete"]
  - apiGroups: [""]
    resources: ["persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch", "update", "patch"]
  - apiGroups: ["csi.storage.k8s.io"]
    resources: ["csinodeinfos"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["csinodes"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["volumeattachments"]
    verbs: ["get", "list", "watch", "update"]
  - apiGroups: ["storage.k8s.io"]
    resources: ["volumeattachments/status"]
    verbs: ["get", "list", "watch", "update", "patch"]
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["list", "watch", "create", "update", "patch"]
  - apiGroups: ["security.openshift.io"]
    resources: ["securitycontextconstraints"]
    verbs: ["use"]
    resourceNames: ["privileged"]
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: kubevirt-csi-controller-binding
subjects:
  - kind: ServiceAccount
    name: kubevirt-csi-controller-sa
    namespace: kubevirt-csi-driver
roleRef:
  kind: ClusterRole
  name: kubevirt-csi-controller-cr
  apiGroup: rbac.authorization.k8s.io
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: kubevirt-csi-node-binding
subjects:
  - kind: ServiceAccount
    name: kubevirt-csi-node-sa
    namespace: kubevirt-csi-driver
roleRef:
  kind: ClusterRole
  name: kubevirt-csi-node-cr
  apiGroup: rbac.authorization.k8s.io
---
`)

func deploy020AutorizationYamlBytes() ([]byte, error) {
	return _deploy020AutorizationYaml, nil
}

func deploy020AutorizationYaml() (*asset, error) {
	bytes, err := deploy020AutorizationYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/020-autorization.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deploy030NodeYaml = []byte(`#TODO: Force DaemonSet to not run on master - see
kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: kubevirt-csi-node
  namespace: kubevirt-csi-driver
spec:
  selector:
    matchLabels:
      app: kubevirt-csi-driver
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: kubevirt-csi-driver
    spec:
      hostNetwork: true
      serviceAccount: kubevirt-csi-node-sa
      priorityClassName: system-node-critical
      tolerations:
        - operator: Exists
      containers:
        - name: csi-driver
          securityContext:
            privileged: true
            allowPrivilegeEscalation: true
          imagePullPolicy: Always
          image: quay.io/kubevirt/csi-driver:latest
          args:
            - "--endpoint=unix:/csi/csi.sock"
            - "--namespace=kubevirt-csi-driver"
            - "--node-name=$(KUBE_NODE_NAME)"
            - "--infra-cluster-namespace=$(INFRACLUSTER_NAMESPACE)"
            - "--infra-cluster-kubeconfig=/var/run/secrets/infracluster/kubeconfig"
          env:
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
            - name: INFRACLUSTER_NAMESPACE
              valueFrom:
                configMapKeyRef:
                  name: driver-config
                  key: infraClusterNamespace
            - name: INFRACLUSTER_LABELS
              valueFrom:
                configMapKeyRef:
                  name: driver-config
                  key: infraClusterLabels
          volumeMounts:
            - name: infracluster
              mountPath: "/var/run/secrets/infracluster"
            - name: kubelet-dir
              mountPath: /var/lib/kubelet
              mountPropagation: "Bidirectional"
            - name: plugin-dir
              mountPath: /csi
            - name: device-dir
              mountPath: /dev
            - name: udev
              mountPath: /run/udev
          ports:
            - name: healthz
              # due to hostNetwork, this port is open on a node!
              containerPort: 10300
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /healthz
              port: healthz
            initialDelaySeconds: 10
            timeoutSeconds: 3
            periodSeconds: 10
            failureThreshold: 5
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
        - name: csi-node-driver-registrar
          securityContext:
            privileged: true
          image: quay.io/openshift/origin-csi-node-driver-registrar:latest
          args:
            - --csi-address=$(ADDRESS)
            - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)
            - --v=5
          lifecycle:
            preStop:
              exec:
                command: ["/bin/sh", "-c", "rm -rf /registration/csi.kubevirt.io-reg.sock /csi/csi.sock"]
          env:
            - name: ADDRESS
              value: /csi/csi.sock
            - name: DRIVER_REG_SOCK_PATH
              value: /var/lib/kubelet/plugins/csi.kubevirt.io/csi.sock
          volumeMounts:
            - name: plugin-dir
              mountPath: /csi
            - name: registration-dir
              mountPath: /registration
          resources:
            requests:
              memory: 20Mi
              cpu: 5m
        - name: csi-liveness-probe
          image: quay.io/openshift/origin-csi-livenessprobe:latest
          args:
            - --csi-address=/csi/csi.sock
            - --probe-timeout=3s
            - --health-port=10300
          volumeMounts:
            - name: plugin-dir
              mountPath: /csi
          resources:
            requests:
              memory: 20Mi
              cpu: 5m
      volumes:
        - name: infracluster
          secret:
            secretName: infra-cluster-credentials
        - name: kubelet-dir
          hostPath:
            path: /var/lib/kubelet
            type: Directory
        - name: plugin-dir
          hostPath:
            path: /var/lib/kubelet/plugins/csi.kubevirt.io/
            type: DirectoryOrCreate
        - name: registration-dir
          hostPath:
            path: /var/lib/kubelet/plugins_registry/
            type: Directory
        - name: device-dir
          hostPath:
            path: /dev
            type: Directory
        - name: udev
          hostPath:
            path: /run/udev
`)

func deploy030NodeYamlBytes() ([]byte, error) {
	return _deploy030NodeYaml, nil
}

func deploy030NodeYaml() (*asset, error) {
	bytes, err := deploy030NodeYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/030-node.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deploy040ControllerYaml = []byte(`kind: Deployment
apiVersion: apps/v1
metadata:
  name: kubevirt-csi-controller
  namespace: kubevirt-csi-driver
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kubevirt-csi-driver
  template:
    metadata:
      labels:
        app: kubevirt-csi-driver
    spec:
      hostNetwork: true
      serviceAccount: kubevirt-csi-controller-sa
      priorityClassName: system-cluster-critical
      nodeSelector:
        node-role.kubernetes.io/master: ""
      tolerations:
        - key: CriticalAddonsOnly
          operator: Exists
        - key: node-role.kubernetes.io/master
          operator: Exists
          effect: "NoSchedule"
      containers:
        - name: csi-driver
          imagePullPolicy: Always
          image: quay.io/kubevirt/csi-driver:latest
          args:
            - "--endpoint=$(CSI_ENDPOINT)"
            - "--namespace=kubevirt-csi-driver"
            - "--infra-cluster-namespace=$(INFRACLUSTER_NAMESPACE)"
            - "--infra-cluster-kubeconfig=/var/run/secrets/infracluster/kubeconfig"
            - "--infra-cluster-labels=$(INFRACLUSTER_LABELS)"
            - --v=5
          ports:
            - name: healthz
              # Due to hostNetwork, this port is open on a node!
              containerPort: 10301
              protocol: TCP
          env:
            - name: CSI_ENDPOINT
              value: unix:///var/lib/csi/sockets/pluginproxy/csi.sock
            - name: KUBE_NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
            - name: INFRACLUSTER_NAMESPACE
              valueFrom:
                configMapKeyRef:
                  name: driver-config
                  key: infraClusterNamespace
            - name: INFRACLUSTER_LABELS
              valueFrom:
                configMapKeyRef:
                  name: driver-config
                  key: infraClusterLabels
          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy/
            - name: infracluster
              mountPath: "/var/run/secrets/infracluster"
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
        - name: csi-provisioner
          image: quay.io/openshift/origin-csi-external-provisioner:latest
          args:
            - --csi-address=$(ADDRESS)
            - --default-fstype=ext4
            - --v=5
          env:
            - name: ADDRESS
              value: /var/lib/csi/sockets/pluginproxy/csi.sock
          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy/
        - name: csi-attacher
          image: quay.io/openshift/origin-csi-external-attacher:latest
          args:
            - --csi-address=$(ADDRESS)
            - --v=5
          env:
            - name: ADDRESS
              value: /var/lib/csi/sockets/pluginproxy/csi.sock
          volumeMounts:
            - name: socket-dir
              mountPath: /var/lib/csi/sockets/pluginproxy/
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
        - name: csi-liveness-probe
          image: quay.io/openshift/origin-csi-livenessprobe:latest
          args:
            - --csi-address=/csi/csi.sock
            - --probe-timeout=3s
            - --health-port=10301
          volumeMounts:
            - name: socket-dir
              mountPath: /csi
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
      volumes:
        - name: socket-dir
          emptyDir: {}
        - name: infracluster
          secret:
            secretName: infra-cluster-credentials
`)

func deploy040ControllerYamlBytes() ([]byte, error) {
	return _deploy040ControllerYaml, nil
}

func deploy040ControllerYaml() (*asset, error) {
	bytes, err := deploy040ControllerYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/040-controller.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployConfigmapYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: driver-config
  namespace: kubevirt-csi-driver
data:
  infraClusterNamespace: 
  infraClusterLabels: key=value,key=value,...
`)

func deployConfigmapYamlBytes() ([]byte, error) {
	return _deployConfigmapYaml, nil
}

func deployConfigmapYaml() (*asset, error) {
	bytes, err := deployConfigmapYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/configmap.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployExampleInfraclusterKubeconfigYaml = []byte(`apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: <Base64 of CA. Take value from the kubeconfig used to create the ServiceAccount kubevirt-csi>
    server: <URL of cluster. E.g.https://api.crc.testing:6443. Take value from the kubeconfig used to create the ServiceAccount kubevirt-csi>
  name: infra-cluster
contexts:
- context:
    cluster: infra-cluster
    namespace: <optional, not used>
    user: kubevirt-csi
  name: only-context
current-context: only-context
kind: Config
preferences: {}
users:
- name: kubevirt-csi
  user:
    token: <use token from secret in ServiceAccount kubevirt-csi. Decode it from base64 (base64 -d)>
`)

func deployExampleInfraclusterKubeconfigYamlBytes() ([]byte, error) {
	return _deployExampleInfraclusterKubeconfigYaml, nil
}

func deployExampleInfraclusterKubeconfigYaml() (*asset, error) {
	bytes, err := deployExampleInfraclusterKubeconfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/example/infracluster-kubeconfig.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployExampleKubevirtConfigYaml = []byte(`apiVersion: v1
kind: ConfigMap
metadata:
  name: kubevirt-config
  namespace: kubevirt
data:
  default-network-interface: masquerade
  feature-gates: DataVolumes,SRIOV,LiveMigration,CPUManager,CPUNodeDiscovery,Sidecar,Snapshot,HotplugVolumes
  selinuxLauncherType: virt_launcher.process
  smbios: |-
    Family: KubeVirt
    Manufacturer: KubeVirt
    Product: None
`)

func deployExampleKubevirtConfigYamlBytes() ([]byte, error) {
	return _deployExampleKubevirtConfigYaml, nil
}

func deployExampleKubevirtConfigYaml() (*asset, error) {
	bytes, err := deployExampleKubevirtConfigYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/example/kubevirt-config.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployExampleKubevirtYaml = []byte(`apiVersion: kubevirt.io/v1alpha3
kind: KubeVirt
metadata:
  name: kubevirt
  namespace: kubevirt
spec:
  certificateRotateStrategy: {}
  configuration:
    developerConfiguration:
      featureGates:
      - DataVolumes
      - SRIOV
      - LiveMigration
      - CPUManager
      - CPUNodeDiscovery
      - Sidecar
      - Snapshot
      - HotplugVolumes
    network:
      defaultNetworkInterface: masquerade
    smbios:
      family: KubeVirt
      manufacturer: KubeVirt
      product: None
      selinuxLauncherType: virt_launcher.process
  customizeComponents: {}
  uninstallStrategy: BlockUninstallIfWorkloadsExist
`)

func deployExampleKubevirtYamlBytes() ([]byte, error) {
	return _deployExampleKubevirtYaml, nil
}

func deployExampleKubevirtYaml() (*asset, error) {
	bytes, err := deployExampleKubevirtYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/example/kubevirt.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployExampleStorageClaimYaml = []byte(`kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: 1g-kubevirt-disk
spec:
  storageClassName: kubevirt
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
`)

func deployExampleStorageClaimYamlBytes() ([]byte, error) {
	return _deployExampleStorageClaimYaml, nil
}

func deployExampleStorageClaimYaml() (*asset, error) {
	bytes, err := deployExampleStorageClaimYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/example/storage-claim.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployExampleStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: kubevirt
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: csi.kubevirt.io
parameters:
  infraStorageClassName: standard
  bus: scsi
`)

func deployExampleStorageclassYamlBytes() ([]byte, error) {
	return _deployExampleStorageclassYaml, nil
}

func deployExampleStorageclassYaml() (*asset, error) {
	bytes, err := deployExampleStorageclassYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/example/storageclass.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployExampleTestPodYaml = []byte(`apiVersion: v1 
kind: Pod 
metadata:
  name: testpodwithcsi
spec:
  containers:
  - image: busybox
    name: testpodwithcsi
    command: ["sh", "-c", "while true; do ls -la /opt; echo this file system was made availble using kubevirt-csi-driver; mktmp /opt/test-XXXXXX; sleep 1m; done"]
    imagePullPolicy: Always
    volumeMounts:
    - name: pv0002
      mountPath: "/opt"
  volumes:
  - name: pv0002
    persistentVolumeClaim:
      claimName: 1g-kubevirt-disk
`)

func deployExampleTestPodYamlBytes() ([]byte, error) {
	return _deployExampleTestPodYaml, nil
}

func deployExampleTestPodYaml() (*asset, error) {
	bytes, err := deployExampleTestPodYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/example/test-pod.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deployInfraClusterServiceAccountYaml = []byte(`apiVersion: v1
kind: ServiceAccount
metadata:
  name: kubevirt-csi
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: kubevirt-csi
rules:
- apiGroups: ["cdi.kubevirt.io"]
  resources: ["datavolumes"]
  verbs: ["get", "create", "delete"]
- apiGroups: ["kubevirt.io"]
  resources: ["virtualmachineinstances"]
  verbs: ["list"]
- apiGroups: ["subresources.kubevirt.io"]
  resources: ["virtualmachineinstances/addvolume", "virtualmachineinstances/removevolume"]
  verbs: ["update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kubevirt-csi
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kubevirt-csi
subjects:
- kind: ServiceAccount
  name: kubevirt-csi
---`)

func deployInfraClusterServiceAccountYamlBytes() ([]byte, error) {
	return _deployInfraClusterServiceAccountYaml, nil
}

func deployInfraClusterServiceAccountYaml() (*asset, error) {
	bytes, err := deployInfraClusterServiceAccountYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/infra-cluster-service-account.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

var _deploySecretYaml = []byte(`apiVersion: v1
kind: Secret
metadata:
  name: infra-cluster-credentials
  namespace: kubevirt-csi-driver
data:
  kubeconfig: `)

func deploySecretYamlBytes() ([]byte, error) {
	return _deploySecretYaml, nil
}

func deploySecretYaml() (*asset, error) {
	bytes, err := deploySecretYamlBytes()
	if err != nil {
		return nil, err
	}

	info := bindataFileInfo{name: "deploy/secret.yaml", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}
	a := &asset{bytes: bytes, info: info}
	return a, nil
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"deploy/000-csi-driver.yaml":                  deploy000CsiDriverYaml,
	"deploy/000-namespace.yaml":                   deploy000NamespaceYaml,
	"deploy/020-autorization.yaml":                deploy020AutorizationYaml,
	"deploy/030-node.yaml":                        deploy030NodeYaml,
	"deploy/040-controller.yaml":                  deploy040ControllerYaml,
	"deploy/configmap.yaml":                       deployConfigmapYaml,
	"deploy/example/infracluster-kubeconfig.yaml": deployExampleInfraclusterKubeconfigYaml,
	"deploy/example/kubevirt-config.yaml":         deployExampleKubevirtConfigYaml,
	"deploy/example/kubevirt.yaml":                deployExampleKubevirtYaml,
	"deploy/example/storage-claim.yaml":           deployExampleStorageClaimYaml,
	"deploy/example/storageclass.yaml":            deployExampleStorageclassYaml,
	"deploy/example/test-pod.yaml":                deployExampleTestPodYaml,
	"deploy/infra-cluster-service-account.yaml":   deployInfraClusterServiceAccountYaml,
	"deploy/secret.yaml":                          deploySecretYaml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}

var _bintree = &bintree{nil, map[string]*bintree{
	"deploy": {nil, map[string]*bintree{
		"000-csi-driver.yaml":   {deploy000CsiDriverYaml, map[string]*bintree{}},
		"000-namespace.yaml":    {deploy000NamespaceYaml, map[string]*bintree{}},
		"020-autorization.yaml": {deploy020AutorizationYaml, map[string]*bintree{}},
		"030-node.yaml":         {deploy030NodeYaml, map[string]*bintree{}},
		"040-controller.yaml":   {deploy040ControllerYaml, map[string]*bintree{}},
		"configmap.yaml":        {deployConfigmapYaml, map[string]*bintree{}},
		"example": {nil, map[string]*bintree{
			"infracluster-kubeconfig.yaml": {deployExampleInfraclusterKubeconfigYaml, map[string]*bintree{}},
			"kubevirt-config.yaml":         {deployExampleKubevirtConfigYaml, map[string]*bintree{}},
			"kubevirt.yaml":                {deployExampleKubevirtYaml, map[string]*bintree{}},
			"storage-claim.yaml":           {deployExampleStorageClaimYaml, map[string]*bintree{}},
			"storageclass.yaml":            {deployExampleStorageclassYaml, map[string]*bintree{}},
			"test-pod.yaml":                {deployExampleTestPodYaml, map[string]*bintree{}},
		}},
		"infra-cluster-service-account.yaml": {deployInfraClusterServiceAccountYaml, map[string]*bintree{}},
		"secret.yaml":                        {deploySecretYaml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}
